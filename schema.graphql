type Category {
	id: UUID!
	name: String!
	values: [CategoryValue!]!
}

type CategoryValue {
	id: UUID!
	categoryId: UUID!
	value: String!
}

input CreateCategory {
	id: UUID
	name: String!
}

input CreateCategoryValue {
	id: UUID
	categoryId: UUID!
	value: String!
}

input CreateDive {
	id: UUID
	date: DateTime!
	duration: Int!
	depth: Float!
	diveSiteId: UUID
	description: String!
	published: Boolean!
	decoModel: String
}

input CreateDiveComment {
	id: UUID
	diveId: UUID!
	description: String!
}

input CreateDiveSite {
	id: UUID
	name: String!
	description: String!
	access: String!
	difficulty: Difficulty!
	depth: Float!
	photoId: UUID
	lat: Float!
	lon: Float!
	published: Boolean!
}

input CreatePhoto {
	id: UUID
	userId: UUID!
	filename: String!
	date: DateTime!
	diveId: UUID
	size: Int!
	internal: Boolean
	diveSiteId: UUID
	sealifeId: UUID
}

input CreateRegion {
	id: UUID
	name: String!
	latMin: Float!
	lonMin: Float!
	latMax: Float!
	lonMax: Float!
}

input CreateSealife {
	id: UUID
	name: String!
	scientificName: String
	description: String!
	photoId: UUID
	categoryMap: JSONObject
	hideLocation: Boolean!
}

"""
Implement the DateTime<Utc> scalar

The input/output is a string in RFC3339 format.
"""
scalar DateTime

enum Difficulty {
	OW
	AOW
	TECH
}

type Dive {
	id: UUID!
	userId: UUID!
	date: DateTime!
	description: String!
	summary: String!
	duration: Int!
	depth: Float!
	latestPhotos: [Photo!]!
	number: Int!
	published: Boolean!
	likes: Int!
	liked: Boolean!
	numComments: Int!
	comments: [DiveComment!]!
	hasMetrics: Boolean!
	diveSiteId: UUID
	diveSite: DiveSite
	user: PublicUserInfo!
}

type DiveComment {
	id: UUID!
	userId: UUID!
	user: PublicUserInfo!
	diveId: UUID!
	dive: Dive!
	date: DateTime!
	description: String!
}

input DivePlanInput {
	time: Int!
	depth: Float!
	gfLow: Int!
	gfHigh: Int!
	backGas: GasInput!
	decoGasses: [GasInput!]!
}

type DiveSchedule {
	runtime: Int!
	tts: Int!
	stages: [DiveStage!]!
	smallChart: String!
	bigChart: String!
}

type DiveSite {
	id: UUID!
	userId: UUID
	name: String!
	description: String!
	summary: String!
	access: String!
	difficulty: Difficulty!
	depth: Float!
	lat: Float!
	lon: Float!
	published: Boolean!
	date: DateTime!
	slug: String
	siteMetrics: SiteMetric!
	photoId: UUID
	photo: Photo
	latestPhotos: [Photo!]!
	latestDives: [Dive!]!
	references: [OgReference!]!
}

type DiveStage {
	stageType: StageType!
	time: Int!
	depth: Float!
	gas: GasOutput
}

type Feedback {
	id: UUID!
	userId: UUID!
	user: UserInfo!
	date: DateTime!
	feedback: String!
}

input GasInput {
	litres: Float!
	o2: Float!
	he: Float!
}

type GasOutput {
	o2: Float!
	he: Float!
}

"""
A scalar that can represent any JSON Object value.
"""
scalar JSONObject

type LoginResponse {
	id: UUID!
	email: String!
	token: String!
	level: UserLevel!
	username: String!
	displayName: String
	watermarkLocation: OverlayLocation!
	copyrightLocation: OverlayLocation
	description: String!
	photoId: UUID
	emailVerified: Boolean!
}

type Mutation {
	requestResetToken(email: String!): Boolean!
	changePassword(oldPassword: String!, newPassword: String!): Boolean!
	resetPassword(email: String!, newPassword: String!, token: UUID!): LoginResponse!
	registerUser(username: String!, email: String!, password: String!): Boolean!
	fbRegisterUser(username: String!, redirectUri: String!, code: String!): LoginResponse!
	login(email: String!, password: String!): LoginResponse!
	fbLogin(redirectUri: String!, code: String!): LoginResponse!
	oauthAuthorizationUrl: String!
	oauthCallback(code: String!, state: String!): LoginResponse!
	updateSettings(displayName: String, watermarkLocation: OverlayLocation!, copyrightLocation: OverlayLocation, description: String!, photoId: UUID): LoginResponse
	syncSubsurface(email: String!, password: String!): Boolean!
	addFeedback(feedback: String!): Feedback!
	newCategory(category: CreateCategory!): Category!
	removeCategory(categoryId: UUID!): Boolean!
	removeCategoryValue(categoryValueId: UUID!): Boolean!
	newCategoryValue(categoryValue: CreateCategoryValue!): CategoryValue!
	newDive(dive: CreateDive!): Dive!
	removeDive(id: UUID!): Boolean!
	likeDive(diveId: UUID!): Boolean!
	unlikeDive(diveId: UUID!): Boolean!
	newComment(comment: CreateDiveComment!): DiveComment!
	removeComment(id: UUID!): Boolean!
	newDiveSite(site: CreateDiveSite!): DiveSite!
	mergeDiveSites(fromId: UUID!, toId: UUID!): Boolean!
	removeDiveSite(id: UUID!): Boolean!
	deleteUser(password: String!): Boolean!
	updatePhoto(photo: CreatePhoto!): Photo!
	removePhoto(id: UUID!): Boolean!
	likePhoto(photoId: UUID!): Boolean!
	unlikePhoto(photoId: UUID!): Boolean!
	newSealife(sealife: CreateSealife!): Sealife!
	removeSealife(id: UUID!): Boolean!
	checkReference(url: String!): OgReference!
	newReference(url: String!, sealifeId: UUID, diveSiteId: UUID): OgReference!
	removeReference(id: UUID!): Boolean!
	newRegion(region: CreateRegion!): Region!
	removeRegion(id: UUID!): Boolean!
	verifyEmail(email: String!, token: UUID!): LoginResponse!
	resendVerification: Boolean!
	planDive(plan: DivePlanInput!): DiveSchedule!
}

type OgReference {
	id: UUID!
	url: String!
	title: String!
	imageUrl: String
	description: String!
	lastFetched: DateTime!
}

enum OverlayLocation {
	TOP_LEFT
	TOP_RIGHT
	BOTTOM_LEFT
	BOTTOM_RIGHT
}

type Photo {
	id: UUID!
	userId: UUID!
	date: DateTime
	filename: String!
	size: Float!
	width: Float!
	height: Float!
	dive: Dive
	sealife: Sealife
	diveSite: DiveSite
	likes: Int!
	liked: Boolean!
	user: PublicUserInfo!
}

type PublicUserInfo {
	id: UUID!
	username: String!
	displayName: String
	description: String!
	photoId: UUID
	photo: Photo
	photoCount: Int!
	diveCount: Int!
	latestDives: [Dive!]!
	latestPhotos: [Photo!]!
}

type Query {
	siteUrl: String!
	fbAppId: String!
	openidIssuerName: String
	disableEmailLogin: Boolean!
	categories: [Category!]!
	categoryValues: [CategoryValue!]!
	search(query: String!, offset: Int): [SearchResult!]!
	dives(id: UUID, diveSite: UUID, maxDepth: Float, userId: UUID, username: String, offset: Int): [Dive!]!
	recentDives: [Dive!]!
	user(username: String!): PublicUserInfo!
	currentUser: LoginResponse
	diveSites(id: UUID, name: String, maxDepth: Float, slug: String): [DiveSite!]!
	popularDiveSites: [DiveSite!]!
	photos(id: UUID, userId: UUID, username: String, diveSite: UUID, dive: UUID, sealifeId: UUID, offset: Int, orderByUpload: Boolean): [Photo!]!
	regions: [Region!]!
	sealife(id: UUID, name: String, scientificName: String, slug: String, categoryValues: [UUID!]): [Sealife!]!
	feedback(id: UUID): [Feedback!]!
}

type Region {
	id: UUID!
	name: String!
	latMin: Float!
	lonMin: Float!
	latMax: Float!
	lonMax: Float!
	slug: String!
}

type Sealife {
	id: UUID!
	name: String!
	scientificName: String
	description: String!
	date: DateTime!
	summary: String!
	photoId: UUID
	photo: Photo
	latestPhotos: [Photo!]!
	categoryMap: JSONObject!
	slug: String
	references: [OgReference!]!
	hideLocation: Boolean!
}

type SearchResult {
	id: String!
	kind: SearchResultKind!
	photoId: String
	slug: String!
	name: String!
	scientificName: String
	summary: String!
}

enum SearchResultKind {
	SEALIFE
	DIVE_SITE
}

type SiteMetric {
	photoCount: Int!
	diveCount: Int!
}

enum StageType {
	ASCEND
	DESCEND
	STAY
	GAS_CHANGE
}

"""
A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
Strings within GraphQL. UUIDs are used to assign unique identifiers to
entities without requiring a central allocating authority.

# References

* [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC4122: A Universally Unique Identifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
"""
scalar UUID

type UserInfo {
	id: UUID!
	email: String
	level: UserLevel!
	username: String!
	displayName: String
	description: String!
	emailVerified: Boolean!
}

enum UserLevel {
	USER
	EDITOR
	ADMIN
}

"""
Directs the executor to include this field or fragment only when the `if` argument is true.
"""
directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
"""
Directs the executor to skip this field or fragment when the `if` argument is true.
"""
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
"""
Provides a scalar specification URL for specifying the behavior of custom scalar types.
"""
directive @specifiedBy(url: String!) on SCALAR
schema {
	query: Query
	mutation: Mutation
}
